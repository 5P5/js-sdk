{"version":3,"file":"pocketbase.iife.js","sources":["../src/ClientResponseError.ts","../src/stores/utils/cookie.ts","../src/stores/utils/jwt.ts","../src/stores/BaseAuthStore.ts","../src/stores/LocalAuthStore.ts","../src/services/utils/BaseService.ts","../src/services/SettingsService.ts","../src/services/utils/BaseCrudService.ts","../src/services/AdminService.ts","../src/services/RecordService.ts","../src/services/CollectionService.ts","../src/services/LogService.ts","../src/services/RealtimeService.ts","../src/services/HealthService.ts","../src/services/FileService.ts","../src/services/BackupService.ts","../src/Client.ts"],"sourcesContent":["/**\n * ClientResponseError is a custom Error class that is intended to wrap\n * and normalize any error thrown by `Client.send()`.\n */\nexport default class ClientResponseError extends Error {\n    url: string                    = '';\n    status: number                 = 0;\n    response: {[key: string]: any} = {};\n    isAbort:  boolean              = false;\n    originalError: any             = null;\n\n    constructor(errData?: any) {\n        super(\"ClientResponseError\");\n\n        // Set the prototype explicitly.\n        // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, ClientResponseError.prototype);\n\n        if (errData !== null && typeof errData === 'object') {\n            this.url           = typeof errData.url === 'string' ? errData.url : '';\n            this.status        = typeof errData.status === 'number' ? errData.status : 0;\n            this.isAbort       = !!errData.isAbort;\n            this.originalError = errData.originalError;\n\n            if (errData.response !== null && typeof errData.response === 'object')  {\n                this.response =  errData.response;\n            } else if (errData.data !== null && typeof errData.data === 'object')  {\n                this.response =  errData.data;\n            } else {\n                this.response =  {};\n            }\n        }\n\n        if (!this.originalError && !(errData instanceof ClientResponseError)) {\n            this.originalError = errData;\n        }\n\n        if (typeof DOMException !== 'undefined' && errData instanceof DOMException) {\n            this.isAbort = true;\n        }\n\n        this.name = \"ClientResponseError \" + this.status;\n        this.message = this.response?.message;\n        if (!this.message) {\n            if (this.isAbort) {\n                this.message = 'The request was autocancelled. You can find more info in https://github.com/pocketbase/js-sdk#auto-cancellation.';\n            } else if (this.originalError?.cause?.message?.includes(\"ECONNREFUSED ::1\")) {\n                this.message = 'Failed to connect to the PocketBase server. Try changing the SDK URL from localhost to 127.0.0.1 (https://github.com/pocketbase/js-sdk/issues/21).';\n            } else {\n                this.message = 'Something went wrong while processing your request.';\n            }\n        }\n    }\n\n    /**\n     * Alias for `this.response` to preserve the backward compatibility.\n     */\n    get data() {\n        return this.response;\n    }\n\n    /**\n     * Make a POJO's copy of the current error class instance.\n     * @see https://github.com/vuex-orm/vuex-orm/issues/255\n     */\n    toJSON() {\n        return { ...this };\n    }\n}\n","/**\n * -------------------------------------------------------------------\n * Simple cookie parse and serialize utilities mostly based on the\n * node module https://github.com/jshttp/cookie.\n * -------------------------------------------------------------------\n */\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\nexport interface ParseOptions{\n    decode?: (val: string) => string,\n}\n\n/**\n* Parses the given cookie header string into an object\n* The object has the various cookies as keys(names) => values\n*/\nexport function cookieParse(str: string, options?: ParseOptions): { [key: string]: any }  {\n    const result: { [key: string]: any } = {};\n\n    if (typeof str !== 'string') {\n        return result;\n    }\n\n    const opt    = Object.assign({}, options || {});\n    const decode = opt.decode || defaultDecode;\n\n    let index = 0;\n    while (index < str.length) {\n        const eqIdx = str.indexOf('=', index);\n\n        // no more cookie pairs\n        if (eqIdx === -1) {\n            break;\n        }\n\n        let endIdx = str.indexOf(';', index);\n\n        if (endIdx === -1) {\n            endIdx = str.length;\n        } else if (endIdx < eqIdx) {\n            // backtrack on prior semicolon\n            index = str.lastIndexOf(';', eqIdx - 1) + 1;\n            continue;\n        }\n\n        const key = str.slice(index, eqIdx).trim();\n\n        // only assign once\n        if (undefined === result[key]) {\n            let val = str.slice(eqIdx + 1, endIdx).trim();\n\n            // quoted values\n            if (val.charCodeAt(0) === 0x22) {\n                val = val.slice(1, -1);\n            }\n\n            try {\n                result[key] = decode(val);\n            } catch (_) {\n                result[key] = val; // no decoding\n            }\n        }\n\n        index = endIdx + 1;\n    }\n\n    return result;\n};\n\nexport interface SerializeOptions{\n    encode?:   (val: string | number | boolean) => string,\n    maxAge?:   number,\n    domain?:   string,\n    path?:     string,\n    expires?:  Date,\n    httpOnly?: boolean,\n    secure?:   boolean,\n    priority?: string,\n    sameSite?: boolean|string,\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * ```js\n * cookieSerialize('foo', 'bar', { httpOnly: true }) // \"foo=bar; httpOnly\"\n * ```\n */\nexport function cookieSerialize(name: string, val: string, options?: SerializeOptions): string {\n    const opt    = Object.assign({}, options || {});\n    const encode = opt.encode || defaultEncode;\n\n    if (!fieldContentRegExp.test(name)) {\n        throw new TypeError('argument name is invalid');\n    }\n\n    const value = encode(val);\n\n    if (value && !fieldContentRegExp.test(value)) {\n        throw new TypeError('argument val is invalid');\n    }\n\n    let result = name + '=' + value;\n\n    if (opt.maxAge != null) {\n        const maxAge = opt.maxAge - 0;\n\n        if (isNaN(maxAge) || !isFinite(maxAge)) {\n            throw new TypeError('option maxAge is invalid');\n        }\n\n        result += '; Max-Age=' + Math.floor(maxAge);\n    }\n\n    if (opt.domain) {\n        if (!fieldContentRegExp.test(opt.domain)) {\n            throw new TypeError('option domain is invalid');\n        }\n\n        result += '; Domain=' + opt.domain;\n    }\n\n    if (opt.path) {\n        if (!fieldContentRegExp.test(opt.path)) {\n            throw new TypeError('option path is invalid');\n        }\n\n        result += '; Path=' + opt.path;\n    }\n\n    if (opt.expires) {\n        if (!isDate(opt.expires) || isNaN(opt.expires.valueOf())) {\n            throw new TypeError('option expires is invalid');\n        }\n\n        result += '; Expires=' + opt.expires.toUTCString();\n    }\n\n    if (opt.httpOnly) {\n        result += '; HttpOnly';\n    }\n\n    if (opt.secure) {\n        result += '; Secure';\n    }\n\n    if (opt.priority) {\n        const priority = typeof opt.priority === 'string' ? opt.priority.toLowerCase() : opt.priority;\n\n        switch (priority) {\n            case 'low':\n                result += '; Priority=Low';\n                break;\n            case 'medium':\n                result += '; Priority=Medium';\n                break;\n            case 'high':\n                result += '; Priority=High';\n                break;\n            default:\n                throw new TypeError('option priority is invalid');\n        }\n    }\n\n    if (opt.sameSite) {\n        const sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n        switch (sameSite) {\n            case true:\n                result += '; SameSite=Strict';\n                break;\n            case 'lax':\n                result += '; SameSite=Lax';\n                break;\n            case 'strict':\n                result += '; SameSite=Strict';\n                break;\n            case 'none':\n                result += '; SameSite=None';\n                break;\n            default:\n                throw new TypeError('option sameSite is invalid');\n        }\n    }\n\n    return result;\n};\n\n/**\n * Default URL-decode string value function.\n * Optimized to skip native call when no `%`.\n */\nfunction defaultDecode(val: string): string {\n    return val.indexOf('%') !== -1\n        ? decodeURIComponent(val)\n        : val;\n}\n\n/**\n * Default URL-encode value function.\n */\nfunction defaultEncode(val: string | number | boolean): string {\n    return encodeURIComponent(val);\n}\n\n/**\n * Determines if value is a Date.\n */\nfunction isDate(val: any): boolean {\n    return (\n        Object.prototype.toString.call(val) === '[object Date]' ||\n        val instanceof Date\n    );\n}\n","let atobPolyfill: Function;\nif (typeof atob === 'function') {\n    atobPolyfill = atob\n} else {\n    /**\n     * The code was extracted from:\n     * https://github.com/davidchambers/Base64.js\n     */\n    atobPolyfill = (input: any) => {\n        const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n        let str = String(input).replace(/=+$/, \"\");\n        if (str.length % 4 == 1) {\n            throw new Error(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n        }\n\n        for (\n            // initialize result and counters\n            var bc = 0, bs, buffer, idx = 0, output = \"\";\n            // get next character\n            (buffer = str.charAt(idx++));\n            // character found in table? initialize bit storage and add its ascii value;\n            ~buffer &&\n            ((bs = bc % 4 ? (bs as any) * 64 + buffer : buffer),\n                // and if not first of each 4 characters,\n                // convert the first 8 bits to one ascii character\n                bc++ % 4) ?\n            (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6)))) :\n            0\n        ) {\n            // try to find character in table (0-63, not found => -1)\n            buffer = chars.indexOf(buffer);\n        }\n\n        return output;\n    };\n}\n\n/**\n * Returns JWT token's payload data.\n */\nexport function getTokenPayload(token: string): { [key: string]: any } {\n    if (token) {\n        try {\n            const encodedPayload = decodeURIComponent(atobPolyfill(token.split('.')[1]).split('').map(function (c: string) {\n                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n            }).join(''));\n\n            return JSON.parse(encodedPayload) || {};\n        } catch (e) {\n        }\n    }\n\n    return {};\n}\n\n/**\n * Checks whether a JWT token is expired or not.\n * Tokens without `exp` payload key are considered valid.\n * Tokens with empty payload (eg. invalid token strings) are considered expired.\n *\n * @param token The token to check.\n * @param [expirationThreshold] Time in seconds that will be subtracted from the token `exp` property.\n */\nexport function isTokenExpired(token: string, expirationThreshold = 0): boolean {\n    let payload = getTokenPayload(token);\n\n    if (\n        Object.keys(payload).length > 0 &&\n        (!payload.exp || (payload.exp - expirationThreshold) > (Date.now() / 1000))\n    ) {\n        return false;\n    }\n\n    return true;\n}\n","import { cookieParse, cookieSerialize, SerializeOptions } from '@/stores/utils/cookie';\nimport { isTokenExpired, getTokenPayload } from '@/stores/utils/jwt';\nimport { RecordModel, AdminModel }  from '@/services/utils/ResponseModels';\n\nexport type AuthModel = RecordModel|AdminModel|null;\n\nexport type OnStoreChangeFunc = (token: string, model: AuthModel) => void;\n\nconst defaultCookieKey = 'pb_auth';\n\n/**\n * Base AuthStore class that is intended to be extended by all other\n * PocketBase AuthStore implementations.\n */\nexport default abstract class BaseAuthStore {\n    protected baseToken: string = '';\n    protected baseModel: AuthModel = null;\n\n    private _onChangeCallbacks: Array<OnStoreChangeFunc> = [];\n\n    /**\n     * Retrieves the stored token (if any).\n     */\n    get token(): string {\n        return this.baseToken;\n    }\n\n    /**\n     * Retrieves the stored model data (if any).\n     */\n    get model(): AuthModel {\n        return this.baseModel;\n    }\n\n    /**\n     * Loosely checks if the store has valid token (aka. existing and unexpired exp claim).\n     */\n    get isValid(): boolean {\n        return !isTokenExpired(this.token);\n    }\n\n    /**\n     * Saves the provided new token and model data in the auth store.\n     */\n    save(token: string, model?: AuthModel): void {\n        this.baseToken = token || '';\n        this.baseModel = model || null;\n\n        this.triggerChange();\n    }\n\n    /**\n     * Removes the stored token and model data form the auth store.\n     */\n    clear(): void {\n        this.baseToken = '';\n        this.baseModel = null;\n        this.triggerChange();\n    }\n\n    /**\n     * Parses the provided cookie string and updates the store state\n     * with the cookie's token and model data.\n     *\n     * NB! This function doesn't validate the token or its data.\n     * Usually this isn't a concern if you are interacting only with the\n     * PocketBase API because it has the proper server-side security checks in place,\n     * but if you are using the store `isValid` state for permission controls\n     * in a node server (eg. SSR), then it is recommended to call `authRefresh()`\n     * after loading the cookie to ensure an up-to-date token and model state.\n     * For example:\n     *\n     * ```js\n     * pb.authStore.loadFromCookie(\"cookie string...\");\n     *\n     * try {\n     *     // get an up-to-date auth store state by veryfing and refreshing the loaded auth model (if any)\n     *     pb.authStore.isValid && await pb.collection('users').authRefresh();\n     * } catch (_) {\n     *     // clear the auth store on failed refresh\n     *     pb.authStore.clear();\n     * }\n     * ```\n     */\n    loadFromCookie(cookie: string, key = defaultCookieKey): void {\n        const rawData = cookieParse(cookie || '')[key] || '';\n\n        let data: { [key: string]: any } = {};\n        try {\n            data = JSON.parse(rawData);\n            // normalize\n            if (typeof data === null || typeof data !== 'object' || Array.isArray(data)) {\n                data = {};\n            }\n        } catch (_) {}\n\n        this.save(data.token || '', data.model || null);\n    }\n\n    /**\n     * Exports the current store state as cookie string.\n     *\n     * By default the following optional attributes are added:\n     * - Secure\n     * - HttpOnly\n     * - SameSite=Strict\n     * - Path=/\n     * - Expires={the token expiration date}\n     *\n     * NB! If the generated cookie exceeds 4096 bytes, this method will\n     * strip the model data to the bare minimum to try to fit within the\n     * recommended size in https://www.rfc-editor.org/rfc/rfc6265#section-6.1.\n     */\n    exportToCookie(options?: SerializeOptions, key = defaultCookieKey): string {\n        const defaultOptions: SerializeOptions = {\n            secure:   true,\n            sameSite: true,\n            httpOnly: true,\n            path:     \"/\",\n        };\n\n        // extract the token expiration date\n        const payload = getTokenPayload(this.token);\n        if (payload?.exp) {\n            defaultOptions.expires = new Date(payload.exp * 1000);\n        } else {\n            defaultOptions.expires = new Date('1970-01-01');\n        }\n\n        // merge with the user defined options\n        options = Object.assign({}, defaultOptions, options);\n\n        const rawData = {\n            token: this.token,\n            model: this.model ? JSON.parse(JSON.stringify(this.model)) : null,\n        };\n\n        let result = cookieSerialize(key, JSON.stringify(rawData), options);\n\n        const resultLength = typeof Blob !== 'undefined' ?\n            (new Blob([result])).size : result.length;\n\n        // strip down the model data to the bare minimum\n        if (rawData.model && resultLength > 4096) {\n            rawData.model = {id: rawData?.model?.id, email: rawData?.model?.email};\n            const extraProps = [\"collectionId\", \"username\", \"verified\"];\n            for (const prop in this.model) {\n                if (extraProps.includes(prop)) {\n                    rawData.model[prop] = this.model[prop];\n                }\n            }\n            result = cookieSerialize(key, JSON.stringify(rawData), options);\n        }\n\n        return result;\n    }\n\n    /**\n     * Register a callback function that will be called on store change.\n     *\n     * You can set the `fireImmediately` argument to true in order to invoke\n     * the provided callback right after registration.\n     *\n     * Returns a removal function that you could call to \"unsubscribe\" from the changes.\n     */\n    onChange(callback: OnStoreChangeFunc, fireImmediately = false): () => void {\n        this._onChangeCallbacks.push(callback);\n\n        if (fireImmediately) {\n            callback(this.token, this.model);\n        }\n\n        return () => {\n            for (let i = this._onChangeCallbacks.length - 1; i >= 0; i--) {\n                if (this._onChangeCallbacks[i] == callback) {\n                    delete this._onChangeCallbacks[i];    // removes the function reference\n                    this._onChangeCallbacks.splice(i, 1); // reindex the array\n                    return;\n                }\n            }\n        }\n    }\n\n    protected triggerChange(): void {\n        for (const callback of this._onChangeCallbacks) {\n            callback && callback(this.token, this.model);\n        }\n    }\n}\n","import BaseAuthStore, { AuthModel } from '@/stores/BaseAuthStore';\n\n/**\n * The default token store for browsers with auto fallback\n * to runtime/memory if local storage is undefined (eg. in node env).\n */\nexport default class LocalAuthStore extends BaseAuthStore {\n    private storageFallback: { [key: string]: any } = {};\n    private storageKey: string\n\n    constructor(storageKey = \"pocketbase_auth\") {\n        super();\n\n        this.storageKey = storageKey;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get token(): string {\n        const data = this._storageGet(this.storageKey) || {};\n\n        return data.token || '';\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get model(): AuthModel {\n        const data = this._storageGet(this.storageKey) || {};\n\n        if (\n            data === null ||\n            typeof data !== 'object' ||\n            data.model === null ||\n            typeof data.model !== 'object'\n        ) {\n            return null;\n        }\n\n        return data.model\n    }\n\n    /**\n     * @inheritdoc\n     */\n    save(token: string, model?: AuthModel) {\n        this._storageSet(this.storageKey, {\n            'token': token,\n            'model': model,\n        });\n\n        super.save(token, model);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    clear() {\n        this._storageRemove(this.storageKey);\n\n        super.clear();\n    }\n\n    // ---------------------------------------------------------------\n    // Internal helpers:\n    // ---------------------------------------------------------------\n\n    /**\n     * Retrieves `key` from the browser's local storage\n     * (or runtime/memory if local storage is undefined).\n     */\n    private _storageGet(key: string): any {\n        if (typeof window !== 'undefined' && window?.localStorage) {\n            const rawValue = window.localStorage.getItem(key) || '';\n            try {\n                return JSON.parse(rawValue);\n            } catch (e) { // not a json\n                return rawValue;\n            }\n        }\n\n        // fallback\n        return this.storageFallback[key];\n    }\n\n    /**\n     * Stores a new data in the browser's local storage\n     * (or runtime/memory if local storage is undefined).\n     */\n    private _storageSet(key: string, value: any) {\n        if (typeof window !== 'undefined' && window?.localStorage) {\n            // store in local storage\n            let normalizedVal = value;\n            if (typeof value !== 'string') {\n                normalizedVal = JSON.stringify(value);\n            }\n            window.localStorage.setItem(key, normalizedVal);\n        } else {\n            // store in fallback\n            this.storageFallback[key] = value;\n        }\n    }\n\n    /**\n     * Removes `key` from the browser's local storage and the runtime/memory.\n     */\n    private _storageRemove(key: string) {\n        // delete from local storage\n        if (typeof window !== 'undefined' && window?.localStorage) {\n            window.localStorage?.removeItem(key);\n        }\n\n        // delete from fallback\n        delete this.storageFallback[key];\n    }\n}\n","import Client from '@/Client';\n\n/**\n * BaseService class that should be inherited from all API services.\n */\nexport default abstract class BaseService {\n    readonly client: Client\n\n    constructor(client: Client) {\n        this.client = client;\n    }\n}\n","import BaseService         from '@/services/utils/BaseService';\nimport { BaseQueryParams } from '@/services/utils/QueryParams';\n\ninterface appleClientSecret {\n    secret: string;\n}\n\nexport default class SettingsService extends BaseService {\n    /**\n     * Fetch all available app settings.\n     */\n    getAll(queryParams: BaseQueryParams = {}): Promise<{[key: string]:any}> {\n        return this.client.send('/api/settings', {\n            'method': 'GET',\n            'params': queryParams,\n        }).then((responseData) => responseData || {});\n    }\n\n    /**\n     * Bulk updates app settings.\n     */\n    update(bodyParams = {}, queryParams: BaseQueryParams = {}): Promise<{[key: string]:any}> {\n        return this.client.send('/api/settings', {\n            'method': 'PATCH',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then((responseData) => responseData || {});\n    }\n\n    /**\n     * Performs a S3 filesystem connection test.\n     *\n     * The currently supported `filesystem` are \"storage\" and \"backups\".\n     */\n    testS3(filesystem: string = \"storage\", queryParams: BaseQueryParams = {}): Promise<boolean> {\n        const bodyParams = {\n            'filesystem': filesystem,\n        };\n\n        return this.client.send('/api/settings/test/s3', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Sends a test email.\n     *\n     * The possible `emailTemplate` values are:\n     * - verification\n     * - password-reset\n     * - email-change\n     */\n    testEmail(toEmail: string, emailTemplate: string, queryParams: BaseQueryParams = {}): Promise<boolean> {\n        const bodyParams = {\n            'email':    toEmail,\n            'template': emailTemplate,\n        };\n\n        return this.client.send('/api/settings/test/email', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Generates a new Apple OAuth2 client secret.\n     */\n    generateAppleClientSecret(\n        clientId: string,\n        teamId: string,\n        keyId: string,\n        privateKey: string,\n        duration: number,\n        bodyParams = {},\n        queryParams: BaseQueryParams = {}\n    ): Promise<appleClientSecret> {\n        bodyParams = Object.assign({\n            clientId,\n            teamId,\n            keyId,\n            privateKey,\n            duration,\n        }, bodyParams);\n\n        return this.client.send('/api/settings/apple/generate-client-secret', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        });\n    }\n}\n","import BaseService         from '@/services/utils/BaseService';\nimport ClientResponseError from '@/ClientResponseError';\nimport { ResultList }      from '@/services/utils/ResponseModels';\n\nimport {\n    BaseQueryParams,\n    ListQueryParams,\n    FullListQueryParams\n} from '@/services/utils/QueryParams';\n\nexport default abstract class CrudService<M> extends BaseService   {\n    /**\n     * Base path for the crud actions (without trailing slash, eg. '/admins').\n     */\n    abstract get baseCrudPath(): string\n\n    /**\n     * Response data decoder.\n     */\n    decode<T = M>(data: { [key: string]: any }): T {\n        return data as T;\n    }\n\n    /**\n     * Returns a promise with all list items batch fetched at once\n     * (by default 500 items per request; to change it set the `batch` query param).\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    getFullList<T = M>(queryParams?: FullListQueryParams): Promise<Array<T>>\n\n    /**\n     * Legacy version of getFullList with explicitly specified batch size.\n     */\n    getFullList<T = M>(batch?: number, queryParams?: ListQueryParams): Promise<Array<T>>\n\n    getFullList<T = M>(batchOrqueryParams?: number|FullListQueryParams, queryParams?: ListQueryParams): Promise<Array<T>> {\n        if (typeof batchOrqueryParams == \"number\") {\n            return this._getFullList<T>(batchOrqueryParams, queryParams);\n        }\n\n        const params = Object.assign({}, batchOrqueryParams, queryParams);\n\n        let batch = 500;\n        if (params.batch) {\n            batch = params.batch;\n            delete params.batch;\n        }\n\n        return this._getFullList<T>(batch, params);\n    }\n\n    /**\n     * Returns paginated items list.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    getList<T = M>(page = 1, perPage = 30, queryParams: ListQueryParams = {}): Promise<ResultList<T>> {\n        queryParams = Object.assign({\n            'page': page,\n            'perPage': perPage,\n        }, queryParams);\n\n        return this.client.send(this.baseCrudPath, {\n            'method': 'GET',\n            'params': queryParams,\n        }).then((responseData: any) => {\n            const items: Array<T> = [];\n\n            if (responseData?.items) {\n                responseData.items = responseData.items || [];\n                for (const item of responseData.items) {\n                    items.push(this.decode<T>(item));\n                }\n                responseData.items = items;\n            }\n\n            return responseData;\n        });\n    }\n\n    /**\n     * Returns the first found item by the specified filter.\n     *\n     * Internally it calls `getList(1, 1, { filter, skipTotal })` and\n     * returns the first found item.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * For consistency with `getOne`, this method will throw a 404\n     * ClientResponseError if no item was found.\n     */\n    getFirstListItem<T = M>(filter: string, queryParams: BaseQueryParams = {}): Promise<T> {\n        queryParams = Object.assign({\n            'filter':     filter,\n            'skipTotal':  1,\n            '$cancelKey': 'one_by_filter_' + this.baseCrudPath + \"_\" + filter,\n        }, queryParams);\n\n        return this.getList<T>(1, 1, queryParams)\n            .then((result) => {\n                if (!result?.items?.length) {\n                    throw new ClientResponseError({\n                        status: 404,\n                        data: {\n                            code: 404,\n                            message: \"The requested resource wasn't found.\",\n                            data: {},\n                        },\n                    });\n                }\n\n                return result.items[0];\n            });\n    }\n\n    /**\n     * Returns single item by its id.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    getOne<T = M>(id: string, queryParams: BaseQueryParams = {}): Promise<T> {\n        return this.client.send(this.baseCrudPath + '/' + encodeURIComponent(id), {\n            'method': 'GET',\n            'params': queryParams\n        }).then((responseData: any) => this.decode(responseData) as any as T);\n    }\n\n    /**\n     * Creates a new item.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    create<T = M>(bodyParams = {}, queryParams: BaseQueryParams = {}): Promise<T> {\n        return this.client.send(this.baseCrudPath, {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then((responseData: any) => this.decode<T>(responseData));\n    }\n\n    /**\n     * Updates an existing item by its id.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    update<T = M>(id: string, bodyParams = {}, queryParams: BaseQueryParams = {}): Promise<T> {\n        return this.client.send(this.baseCrudPath + '/' + encodeURIComponent(id), {\n            'method': 'PATCH',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then((responseData: any) => this.decode<T>(responseData));\n    }\n\n    /**\n     * Deletes an existing item by its id.\n     */\n    delete(id: string, queryParams: BaseQueryParams = {}): Promise<boolean> {\n        return this.client.send(this.baseCrudPath + '/' + encodeURIComponent(id), {\n            'method': 'DELETE',\n            'params': queryParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Returns a promise with all list items batch fetched at once.\n     */\n    protected _getFullList<T = M>(batchSize = 500, queryParams: ListQueryParams = {}): Promise<Array<T>> {\n        queryParams = Object.assign({\n            'skipTotal': 1,\n        }, queryParams);\n\n        let result: Array<T> = [];\n\n        let request = async (page: number): Promise<Array<any>> => {\n            return this.getList(page, batchSize || 500, queryParams).then((list) => {\n                const castedList = (list as any as ResultList<T>);\n                const items      = castedList.items;\n\n                result = result.concat(items);\n\n                if (items.length == list.perPage) {\n                    return request(page + 1);\n                }\n\n                return result;\n            });\n        }\n\n        return request(1);\n    }\n}\n","import BaseCrudService     from '@/services/utils/BaseCrudService';\nimport { BaseQueryParams } from '@/services/utils/QueryParams';\nimport { AdminModel }      from '@/services/utils/ResponseModels';\n\nexport interface AdminAuthResponse {\n    [key: string]: any;\n\n    token: string;\n    admin: AdminModel;\n}\n\nexport default class AdminService extends BaseCrudService<AdminModel> {\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return '/api/admins';\n    }\n\n    // ---------------------------------------------------------------\n    // Post update/delete AuthStore sync\n    // ---------------------------------------------------------------\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the updated id, then\n     * on success the `client.authStore.model` will be updated with the result.\n     */\n    update<T = AdminModel>(id: string, bodyParams = {}, queryParams: BaseQueryParams = {}): Promise<T> {\n        return super.update(id, bodyParams, queryParams).then((item) => {\n            // update the store state if the updated item id matches with the stored model\n            if (\n                this.client.authStore.model &&\n                typeof this.client.authStore.model?.collectionId === 'undefined' && // is not record auth\n                this.client.authStore.model?.id === item.id\n            ) {\n                this.client.authStore.save(this.client.authStore.token, item);\n            }\n\n            return item as any as T;\n        });\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the deleted id,\n     * then on success the `client.authStore` will be cleared.\n     */\n    delete(id: string, queryParams: BaseQueryParams = {}): Promise<boolean> {\n        return super.delete(id, queryParams).then((success) => {\n            // clear the store state if the deleted item id matches with the stored model\n            if (\n                success &&\n                this.client.authStore.model &&\n                typeof this.client.authStore.model?.collectionId === 'undefined' && // is not record auth\n                this.client.authStore.model?.id === id\n            ) {\n                this.client.authStore.clear();\n            }\n\n            return success;\n        });\n    }\n\n    // ---------------------------------------------------------------\n    // Auth handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * Prepare successful authorize response.\n     */\n    protected authResponse(responseData: any): AdminAuthResponse {\n        const admin = this.decode(responseData?.admin || {});\n\n        if (responseData?.token && responseData?.admin) {\n            this.client.authStore.save(responseData.token, admin);\n        }\n\n        return Object.assign({}, responseData, {\n            // normalize common fields\n            'token': responseData?.token || '',\n            'admin': admin,\n        });\n    }\n\n    /**\n     * Authenticate an admin account with its email and password\n     * and returns a new admin token and data.\n     *\n     * On success this method automatically updates the client's AuthStore data.\n     */\n    authWithPassword(\n        email: string,\n        password: string,\n        bodyParams = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<AdminAuthResponse> {\n        bodyParams = Object.assign({\n            'identity': email,\n            'password': password,\n        }, bodyParams);\n\n        return this.client.send(this.baseCrudPath + '/auth-with-password', {\n            'method':  'POST',\n            'params':  queryParams,\n            'body':    bodyParams,\n        }).then(this.authResponse.bind(this));\n    }\n\n    /**\n     * Refreshes the current admin authenticated instance and\n     * returns a new token and admin data.\n     *\n     * On success this method automatically updates the client's AuthStore data.\n     */\n    authRefresh(bodyParams = {}, queryParams: BaseQueryParams = {}): Promise<AdminAuthResponse> {\n        return this.client.send(this.baseCrudPath + '/auth-refresh', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(this.authResponse.bind(this));\n    }\n\n    /**\n     * Sends admin password reset request.\n     */\n    requestPasswordReset(\n        email: string,\n        bodyParams = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'email': email,\n        }, bodyParams);\n\n        return this.client.send(this.baseCrudPath + '/request-password-reset', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Confirms admin password reset request.\n     */\n    confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        bodyParams = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'token':           passwordResetToken,\n            'password':        password,\n            'passwordConfirm': passwordConfirm,\n        }, bodyParams);\n\n        return this.client.send(this.baseCrudPath + '/confirm-password-reset', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n}\n","import Client              from '@/Client';\nimport ClientResponseError from '@/ClientResponseError';\nimport BaseCrudService     from '@/services/utils/BaseCrudService';\nimport { ResultList, RecordModel, ExternalAuthModel }     from '@/services/utils/ResponseModels';\nimport { UnsubscribeFunc } from '@/services/RealtimeService';\nimport {\n    BaseQueryParams,\n    RecordQueryParams,\n    RecordListQueryParams,\n    RecordFullListQueryParams,\n} from '@/services/utils/QueryParams';\n\nexport interface RecordAuthResponse<T = RecordModel> {\n    record: T;\n    token:  string;\n    meta?:  {[key: string]: any};\n}\n\nexport interface AuthProviderInfo {\n    name:                string;\n    state:               string;\n    codeVerifier:        string;\n    codeChallenge:       string;\n    codeChallengeMethod: string;\n    authUrl:             string;\n}\n\nexport interface AuthMethodsList {\n    usernamePassword: boolean;\n    emailPassword:    boolean;\n    authProviders:    Array<AuthProviderInfo>;\n}\n\nexport interface RecordSubscription<T = RecordModel> {\n    action: string; // eg. create, update, delete\n    record: T;\n}\n\nexport type OAuth2UrlCallback = (url: string) => void|Promise<void>;\n\nexport interface OAuth2AuthConfig {\n    // the name of the OAuth2 provider (eg. \"google\")\n    provider: string;\n\n    // custom scopes to overwrite the default ones\n    scopes?: Array<string>;\n\n    // optional record create data\n    createData?: {[key: string]: any};\n\n    // optional callback that is triggered after the OAuth2 sign-in/sign-up url generation\n    urlCallback?: OAuth2UrlCallback;\n\n    // optional query params to send with the PocketBase auth request (eg. fields, expand, etc.)\n    query?: RecordQueryParams;\n\n    // optional body params to send with the PocketBase auth request\n    body?: {[key: string]: any};\n}\n\nexport default class RecordService extends BaseCrudService<RecordModel> {\n    readonly collectionIdOrName: string;\n\n    constructor(client: Client, collectionIdOrName: string) {\n        super(client);\n\n        this.collectionIdOrName = collectionIdOrName;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return this.baseCollectionPath + '/records';\n    }\n\n    /**\n     * Returns the current collection service base path.\n     */\n    get baseCollectionPath(): string {\n        return '/api/collections/' + encodeURIComponent(this.collectionIdOrName);\n    }\n\n    // ---------------------------------------------------------------\n    // Realtime handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * @deprecated Use subscribe(recordId, callback) instead.\n     *\n     * Subscribe to the realtime changes of a single record in the collection.\n     */\n    async subscribeOne<T = RecordModel>(recordId: string, callback: (data: RecordSubscription<T>) => void): Promise<UnsubscribeFunc> {\n        console.warn(\"PocketBase: subscribeOne(recordId, callback) is deprecated. Please replace it with subscribe(recordId, callback).\");\n        return this.client.realtime.subscribe(this.collectionIdOrName + \"/\" + recordId, callback);\n    }\n\n    /**\n     * @deprecated This form of subscribe is deprecated. Please use `subscribe(\"*\", callback)`.\n     */\n    async subscribe<T = RecordModel>(callback: (data: RecordSubscription<T>) => void): Promise<UnsubscribeFunc>\n\n    /**\n     * Subscribe to realtime changes to the specified topic (\"*\" or record id).\n     *\n     * If `topic` is the wildcard \"*\", then this method will subscribe to\n     * any record changes in the collection.\n     *\n     * If `topic` is a record id, then this method will subscribe only\n     * to changes of the specified record id.\n     *\n     * It's OK to subscribe multiple times to the same topic.\n     * You can use the returned `UnsubscribeFunc` to remove only a single subscription.\n     * Or use `unsubscribe(topic)` if you want to remove all subscriptions attached to the topic.\n     */\n    async subscribe<T = RecordModel>(topic: string, callback: (data: RecordSubscription<T>) => void): Promise<UnsubscribeFunc>\n\n    async subscribe<T = RecordModel>(\n        topicOrCallback: string|((data: RecordSubscription<T>) => void),\n        callback?: (data: RecordSubscription<T>) => void\n    ): Promise<UnsubscribeFunc> {\n        if (typeof topicOrCallback === 'function') {\n            console.warn(\"PocketBase: subscribe(callback) is deprecated. Please replace it with subscribe('*', callback).\");\n            return this.client.realtime.subscribe(this.collectionIdOrName, topicOrCallback);\n        }\n\n        if (!callback) {\n            throw new Error(\"Missing subscription callback.\");\n        }\n\n        if (topicOrCallback === \"\") {\n            throw new Error(\"Missing topic.\");\n        }\n\n        let topic = this.collectionIdOrName;\n        if (topicOrCallback !== \"*\") {\n            topic += ('/' + topicOrCallback);\n        }\n\n        return this.client.realtime.subscribe(topic, callback)\n    }\n\n    /**\n     * Unsubscribe from all subscriptions of the specified topic\n     * (\"*\" or record id).\n     *\n     * If `topic` is not set, then this method will unsubscribe from\n     * all subscriptions associated to the current collection.\n     */\n    async unsubscribe(topic?: string): Promise<void> {\n        // unsubscribe wildcard topic\n        if (topic === \"*\") {\n            return this.client.realtime.unsubscribe(this.collectionIdOrName);\n        }\n\n        // unsubscribe recordId topic\n        if (topic) {\n            return this.client.realtime.unsubscribe(this.collectionIdOrName + \"/\" + topic);\n        }\n\n        // unsubscribe from everything related to the collection\n        return this.client.realtime.unsubscribeByPrefix(this.collectionIdOrName);\n    }\n\n    // ---------------------------------------------------------------\n    // Crud handers\n    // ---------------------------------------------------------------\n    /**\n     * @inheritdoc\n     */\n    getFullList<T = RecordModel>(queryParams?: RecordFullListQueryParams): Promise<Array<T>>\n\n    /**\n     * @inheritdoc\n     */\n    getFullList<T = RecordModel>(batch?: number, queryParams?: RecordListQueryParams): Promise<Array<T>>\n\n    /**\n     * @inheritdoc\n     */\n    getFullList<T = RecordModel>(batchOrQueryParams?: number|RecordFullListQueryParams, queryParams?: RecordListQueryParams): Promise<Array<T>> {\n        if (typeof batchOrQueryParams == \"number\") {\n            return super.getFullList<T>(batchOrQueryParams, queryParams);\n        }\n\n        const params = Object.assign({}, batchOrQueryParams, queryParams);\n\n        return super.getFullList<T>(params);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    getList<T = RecordModel>(page = 1, perPage = 30, queryParams: RecordListQueryParams = {}): Promise<ResultList<T>> {\n        return super.getList<T>(page, perPage, queryParams);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    getFirstListItem<T = RecordModel>(filter: string, queryParams: RecordListQueryParams = {}): Promise<T> {\n        return super.getFirstListItem<T>(filter, queryParams);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    getOne<T = RecordModel>(id: string, queryParams: RecordQueryParams = {}): Promise<T> {\n        return super.getOne<T>(id, queryParams);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    create<T = RecordModel>(bodyParams = {}, queryParams: RecordQueryParams = {}): Promise<T> {\n        return super.create<T>(bodyParams, queryParams);\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the updated id, then\n     * on success the `client.authStore.model` will be updated with the result.\n     */\n    update<T = RecordModel>(id: string, bodyParams = {}, queryParams: RecordQueryParams = {}): Promise<T> {\n        return super.update<RecordModel>(id, bodyParams, queryParams).then((item) => {\n            if (\n                // is record auth\n                this.client.authStore.model?.id === item?.id &&\n                (\n                    this.client.authStore.model?.collectionId === this.collectionIdOrName ||\n                    this.client.authStore.model?.collectionName === this.collectionIdOrName\n                )\n            ) {\n                this.client.authStore.save(this.client.authStore.token, item);\n            }\n\n            return item as any as T;\n        });\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the deleted id,\n     * then on success the `client.authStore` will be cleared.\n     */\n    delete(id: string, queryParams: BaseQueryParams = {}): Promise<boolean> {\n        return super.delete(id, queryParams).then((success) => {\n            if (\n                success &&\n                // is record auth\n                this.client.authStore.model?.id === id &&\n                (\n                    this.client.authStore.model?.collectionId === this.collectionIdOrName ||\n                    this.client.authStore.model?.collectionName === this.collectionIdOrName\n                )\n            ) {\n                this.client.authStore.clear();\n            }\n\n            return success;\n        });\n    }\n\n    // ---------------------------------------------------------------\n    // Auth handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * Prepare successful collection authorization response.\n     */\n    protected authResponse<T = RecordModel>(responseData: any): RecordAuthResponse<T> {\n        const record = this.decode(responseData?.record || {});\n\n        this.client.authStore.save(responseData?.token, record);\n\n        return Object.assign({}, responseData, {\n            // normalize common fields\n            'token':  responseData?.token || '',\n            'record': record as any as T,\n        });\n    }\n\n    /**\n     * Returns all available collection auth methods.\n     */\n    listAuthMethods(queryParams: BaseQueryParams = {}): Promise<AuthMethodsList> {\n        return this.client.send(this.baseCollectionPath + '/auth-methods', {\n            'method': 'GET',\n            'params': queryParams,\n        }).then((responseData: any) => {\n            return Object.assign({}, responseData, {\n                // normalize common fields\n                'usernamePassword': !!responseData?.usernamePassword,\n                'emailPassword':    !!responseData?.emailPassword,\n                'authProviders':    Array.isArray(responseData?.authProviders) ? responseData?.authProviders : [],\n            });\n        });\n    }\n\n    /**\n     * Authenticate a single auth collection record via its username/email and password.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     */\n    authWithPassword<T = RecordModel>(\n        usernameOrEmail: string,\n        password: string,\n        bodyParams = {},\n        queryParams: RecordQueryParams = {},\n    ): Promise<RecordAuthResponse<T>> {\n        bodyParams = Object.assign({\n            'identity': usernameOrEmail,\n            'password': password,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/auth-with-password', {\n            'method':  'POST',\n            'params':  queryParams,\n            'body':    bodyParams,\n        }).then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * Authenticate a single auth collection record with OAuth2 code.\n     *\n     * If you don't have an OAuth2 code you may also want to check `authWithOAuth2` method.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     * - the OAuth2 account data (eg. name, email, avatar, etc.)\n     */\n    authWithOAuth2Code<T = RecordModel>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectUrl: string,\n        createData = {},\n        bodyParams = {},\n        queryParams: RecordQueryParams = {},\n    ): Promise<RecordAuthResponse<T>> {\n        bodyParams = Object.assign({\n            'provider':     provider,\n            'code':         code,\n            'codeVerifier': codeVerifier,\n            'redirectUrl':  redirectUrl,\n            'createData':  createData,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/auth-with-oauth2', {\n            'method':  'POST',\n            'params':  queryParams,\n            'body':    bodyParams,\n        }).then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * @deprecated This form of authWithOAuth2 is deprecated.\n     *\n     * Please use `authWithOAuth2Code()` OR its simplified realtime version\n     * as shown in https://pocketbase.io/docs/authentication/#oauth2-integration.\n     */\n    async authWithOAuth2<T = RecordModel>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectUrl: string,\n        createData?: {[key: string]: any},\n        bodyParams?: {[key: string]: any},\n        queryParams?: RecordQueryParams,\n    ): Promise<RecordAuthResponse<T>>\n\n    /**\n     * Authenticate a single auth collection record with OAuth2\n     * **without custom redirects, deeplinks or even page reload**.\n     *\n     * This method initializes a one-off realtime subscription and will\n     * open a popup window with the OAuth2 vendor page to authenticate.\n     * Once the external OAuth2 sign-in/sign-up flow is completed, the popup\n     * window will be automatically closed and the OAuth2 data sent back\n     * to the user through the previously established realtime connection.\n     *\n     * You can specify an optional `urlCallback` prop to customize\n     * the default url `window.open` behavior.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     * - the OAuth2 account data (eg. name, email, avatar, etc.)\n     *\n     * Example:\n     *\n     * ```js\n     * const authData = await pb.collection(\"users\").authWithOAuth2({\n     *     provider: \"google\",\n     * })\n     * ```\n     *\n     * _Site-note_: when creating the OAuth2 app in the provider dashboard\n     * you have to configure `https://yourdomain.com/api/oauth2-redirect`\n     * as redirect URL.\n     */\n    async authWithOAuth2<T = RecordModel>(options: OAuth2AuthConfig): Promise<RecordAuthResponse<T>>\n\n    async authWithOAuth2<T = RecordModel>(...args: any): Promise<RecordAuthResponse<T>> {\n        // fallback to legacy format\n        if (args.length > 1 || typeof args?.[0] === 'string') {\n            console.warn(\"PocketBase: This form of authWithOAuth2() is deprecated and may get removed in the future. Please replace with authWithOAuth2Code() OR use the authWithOAuth2() realtime form as shown in https://pocketbase.io/docs/authentication/#oauth2-integration.\");\n            return this.authWithOAuth2Code<T>(\n                args?.[0] || '',\n                args?.[1] || '',\n                args?.[2] || '',\n                args?.[3] || '',\n                args?.[4] || {},\n                args?.[5] || {},\n                args?.[6] || {},\n            );\n        }\n\n        const config = args?.[0] || {};\n\n        const authMethods = await this.listAuthMethods();\n\n        const provider = authMethods.authProviders.find((p) => p.name === config.provider);\n        if (!provider) {\n            throw new ClientResponseError(new Error(`Missing or invalid provider \"${config.provider}\".`));\n        }\n\n        const redirectUrl = this.client.buildUrl('/api/oauth2-redirect');\n\n        return new Promise(async (resolve, reject) => {\n            try {\n                // initialize a one-off @oauth2 realtime subscription\n                const unsubscribe = await this.client.realtime.subscribe('@oauth2', async (e) => {\n                    const oldState = this.client.realtime.clientId;\n\n                    try {\n                        unsubscribe();\n\n                        if (!e.state || oldState !== e.state) {\n                            throw new Error(\"State parameters don't match.\");\n                        }\n\n                        const authData = await this.authWithOAuth2Code<T>(\n                            provider.name,\n                            e.code,\n                            provider.codeVerifier,\n                            redirectUrl,\n                            config.createData,\n                            config.body,\n                            config.query,\n                        )\n\n                        resolve(authData);\n                    } catch (err) {\n                        reject(new ClientResponseError(err));\n                    }\n                });\n\n                const replacements: {[key: string]: any} = {\n                    \"state\": this.client.realtime.clientId,\n                }\n                if (config.scopes?.length) {\n                    replacements[\"scope\"] = config.scopes.join(\" \");\n                }\n\n                const url = this._replaceQueryParams(provider.authUrl + redirectUrl, replacements);\n\n                await (config.urlCallback ? config.urlCallback(url) : this._defaultUrlCallback(url));\n            } catch (err) {\n                reject(new ClientResponseError(err));\n            }\n        });\n    }\n\n    /**\n     * Refreshes the current authenticated record instance and\n     * returns a new token and record data.\n     *\n     * On success this method also automatically updates the client's AuthStore.\n     */\n    authRefresh<T = RecordModel>(bodyParams = {}, queryParams: RecordQueryParams = {}): Promise<RecordAuthResponse<T>> {\n        return this.client.send(this.baseCollectionPath + '/auth-refresh', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * Sends auth record password reset request.\n     */\n    requestPasswordReset(\n        email: string,\n        bodyParams  = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'email': email,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/request-password-reset', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Confirms auth record password reset request.\n     */\n    confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        bodyParams = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'token':           passwordResetToken,\n            'password':        password,\n            'passwordConfirm': passwordConfirm,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/confirm-password-reset', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Sends auth record verification email request.\n     */\n    requestVerification(\n        email: string,\n        bodyParams = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'email': email,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/request-verification', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Confirms auth record email verification request.\n     */\n    confirmVerification(\n        verificationToken: string,\n        bodyParams  = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'token': verificationToken,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/confirm-verification', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Sends an email change request to the authenticated record model.\n     */\n    requestEmailChange(\n        newEmail: string,\n        bodyParams = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'newEmail': newEmail,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/request-email-change', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Confirms auth record's new email address.\n     */\n    confirmEmailChange(\n        emailChangeToken: string,\n        password: string,\n        bodyParams  = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'token': emailChangeToken,\n            'password': password,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/confirm-email-change', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Lists all linked external auth providers for the specified auth record.\n     */\n    listExternalAuths(\n        recordId: string,\n        queryParams: BaseQueryParams = {}\n    ): Promise<Array<ExternalAuthModel>> {\n        return this.client.send(this.baseCrudPath + '/' + encodeURIComponent(recordId) + '/external-auths', {\n            'method': 'GET',\n            'params': queryParams,\n        });\n    }\n\n    /**\n     * Unlink a single external auth provider from the specified auth record.\n     */\n    unlinkExternalAuth(\n        recordId: string,\n        provider: string,\n        queryParams: BaseQueryParams = {}\n    ): Promise<boolean> {\n        return this.client.send(this.baseCrudPath + '/' + encodeURIComponent(recordId) + '/external-auths/' + encodeURIComponent(provider), {\n            'method': 'DELETE',\n            'params': queryParams,\n        }).then(() => true);\n    }\n\n    // ---------------------------------------------------------------\n\n    // very rudimentary url query params replacement because at the moment\n    // URL (and URLSearchParams) doesn't seem to be fully supported in React Native\n    //\n    // note: for details behind some of the decode/encode parsing check https://unixpapa.com/js/querystring.html\n    private _replaceQueryParams(url: string, replacements: {[key: string]: any} = {}): string {\n        let urlPath = url\n        let query = \"\";\n\n        const queryIndex = url.indexOf(\"?\");\n        if (queryIndex >= 0) {\n            urlPath = url.substring(0, url.indexOf(\"?\"));\n            query = url.substring(url.indexOf(\"?\") + 1);\n        }\n\n        const parsedParams: {[key: string]: string} = {};\n\n        // parse the query parameters\n        const rawParams = query.split(\"&\");\n        for (const param of rawParams) {\n            if (param == \"\") {\n                continue\n            }\n\n            const pair = param.split(\"=\");\n            parsedParams[decodeURIComponent(pair[0].replace(/\\+/g,' '))] = decodeURIComponent((pair[1] || \"\").replace(/\\+/g,' '));\n        }\n\n        // apply the replacements\n        for (let key in replacements) {\n            if (!replacements.hasOwnProperty(key)) {\n                continue;\n            }\n\n            if (replacements[key] == null) {\n                delete parsedParams[key];\n            } else {\n                parsedParams[key] = replacements[key];\n            }\n        }\n\n        // construct back the full query string\n        query = \"\";\n        for (let key in parsedParams) {\n            if (!parsedParams.hasOwnProperty(key)) {\n                continue;\n            }\n\n            if (query != \"\") {\n                query += \"&\";\n            }\n\n            query += encodeURIComponent(key.replace(/%20/g,'+')) + \"=\" + encodeURIComponent(parsedParams[key].replace(/%20/g,'+'));\n        }\n\n        return query != \"\" ? (urlPath + \"?\" + query) : urlPath;\n    }\n\n    private _defaultUrlCallback(url: string) {\n        if (typeof window === \"undefined\" || !window?.open) {\n            throw new ClientResponseError(new Error(`Not in a browser context - please pass a custom urlCallback function.`));\n        }\n\n        let width  = 1024;\n        let height = 768;\n\n        let windowWidth  = window.innerWidth;\n        let windowHeight = window.innerHeight;\n\n        // normalize window size\n        width  = width > windowWidth ? windowWidth : width;\n        height = height > windowHeight ? windowHeight : height;\n\n        let left = (windowWidth / 2) - (width / 2);\n        let top  = (windowHeight / 2) - (height / 2);\n\n        window.open(\n            url,\n            \"oauth2-popup\",\n            'width='+width+',height='+height+',top='+top+',left='+left+',resizable,menubar=no'\n        );\n    }\n}\n","import BaseCrudService     from '@/services/utils/BaseCrudService';\nimport { BaseQueryParams } from '@/services/utils/QueryParams';\nimport {CollectionModel}   from '@/services/utils/ResponseModels';\n\nexport default class CollectionService extends BaseCrudService<CollectionModel> {\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return '/api/collections';\n    }\n\n    /**\n     * Imports the provided collections.\n     *\n     * If `deleteMissing` is `true`, all local collections and schema fields,\n     * that are not present in the imported configuration, WILL BE DELETED\n     * (including their related records data)!\n     */\n    async import(\n        collections: Array<CollectionModel>,\n        deleteMissing: boolean = false,\n        queryParams: BaseQueryParams = {}\n    ): Promise<true> {\n        return this.client.send(this.baseCrudPath + '/import', {\n            'method': 'PUT',\n            'params': queryParams,\n            'body': {\n                'collections':  collections,\n                'deleteMissing': deleteMissing,\n            }\n        }).then(() => true);\n    }\n}\n","import BaseService from '@/services/utils/BaseService';\nimport {\n    ResultList,\n    LogRequestModel,\n}  from '@/services/utils/ResponseModels';\nimport {\n    BaseQueryParams,\n    ListQueryParams,\n    LogStatsQueryParams,\n} from '@/services/utils/QueryParams';\n\nexport interface HourlyStats {\n    total: number;\n    date:  string;\n}\n\nexport default class LogService extends BaseService {\n    /**\n     * Returns paginated logged requests list.\n     */\n    getRequestsList(page = 1, perPage = 30, queryParams: ListQueryParams = {}): Promise<ResultList<LogRequestModel>> {\n        queryParams = Object.assign({\n            'page':    page,\n            'perPage': perPage,\n        }, queryParams);\n\n        return this.client.send('/api/logs/requests', {\n            'method': 'GET',\n            'params': queryParams,\n        });\n    }\n\n    /**\n     * Returns a single logged request by its id.\n     */\n    getRequest(id: string, queryParams: BaseQueryParams = {}): Promise<LogRequestModel> {\n        return this.client.send('/api/logs/requests/' + encodeURIComponent(id), {\n            'method': 'GET',\n            'params': queryParams\n        });\n    }\n\n    /**\n     * Returns request logs statistics.\n     */\n    getRequestsStats(queryParams: LogStatsQueryParams = {}): Promise<Array<HourlyStats>> {\n        return this.client.send('/api/logs/requests/stats', {\n            'method': 'GET',\n            'params': queryParams\n        });\n    }\n}\n","import BaseService         from '@/services/utils/BaseService';\nimport ClientResponseError from '@/ClientResponseError';\n\ninterface promiseCallbacks {\n    resolve: Function\n    reject: Function\n}\n\nexport type UnsubscribeFunc = () => Promise<void>;\n\nexport default class RealtimeService extends BaseService {\n    clientId: string = \"\";\n\n    private eventSource: EventSource | null = null;\n    private subscriptions: { [key: string]: Array<EventListener> } = {};\n    private lastSentTopics: Array<string> = [];\n    private connectTimeoutId: any;\n    private maxConnectTimeout: number = 15000;\n    private reconnectTimeoutId: any;\n    private reconnectAttempts: number = 0;\n    private maxReconnectAttempts: number = Infinity;\n    private predefinedReconnectIntervals: Array<number> = [\n        200, 300, 500, 1000, 1200, 1500, 2000,\n    ];\n    private pendingConnects: Array<promiseCallbacks> = [];\n\n    /**\n     * Returns whether the realtime connection has been established.\n     */\n    get isConnected(): boolean {\n        return !!this.eventSource && !!this.clientId && !this.pendingConnects.length;\n    }\n\n    /**\n     * Register the subscription listener.\n     *\n     * You can subscribe multiple times to the same topic.\n     *\n     * If the SSE connection is not started yet,\n     * this method will also initialize it.\n     */\n    async subscribe(topic: string, callback: (data: any) => void): Promise<UnsubscribeFunc> {\n        if (!topic) {\n            throw new Error('topic must be set.')\n        }\n\n        const listener = function (e: Event) {\n            const msgEvent = (e as MessageEvent);\n\n            let data;\n            try {\n                data = JSON.parse(msgEvent?.data);\n            } catch {}\n\n            callback(data || {});\n        };\n\n        // store the listener\n        if (!this.subscriptions[topic]) {\n            this.subscriptions[topic] = [];\n        }\n        this.subscriptions[topic].push(listener);\n\n        if (!this.isConnected) {\n            // initialize sse connection\n            await this.connect();\n        } else if (this.subscriptions[topic].length === 1) {\n            // send the updated subscriptions (if it is the first for the topic)\n            await this.submitSubscriptions();\n        } else {\n            // only register the listener\n            this.eventSource?.addEventListener(topic, listener);\n        }\n\n        return async (): Promise<void> => {\n            return this.unsubscribeByTopicAndListener(topic, listener);\n        };\n    }\n\n    /**\n     * Unsubscribe from all subscription listeners with the specified topic.\n     *\n     * If `topic` is not provided, then this method will unsubscribe\n     * from all active subscriptions.\n     *\n     * This method is no-op if there are no active subscriptions.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribe(topic?: string): Promise<void> {\n        if (!this.hasSubscriptionListeners(topic)) {\n            return; // already unsubscribed\n        }\n\n        if (!topic) {\n            // remove all subscriptions\n            this.subscriptions = {};\n        } else {\n            // remove all topic listeners\n            for (let listener of this.subscriptions[topic]) {\n                this.eventSource?.removeEventListener(topic, listener);\n            }\n            delete this.subscriptions[topic];\n        }\n\n        if (!this.hasSubscriptionListeners()) {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        } else if (!this.hasSubscriptionListeners(topic)) {\n            // submit subscriptions change if there are no other active subscriptions related to the topic\n            await this.submitSubscriptions();\n        }\n    }\n\n    /**\n     * Unsubscribe from all subscription listeners starting with the specified topic prefix.\n     *\n     * This method is no-op if there are no active subscriptions with the specified topic prefix.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribeByPrefix(topicPrefix: string): Promise<void> {\n        let hasAtleastOneTopic = false;\n        for (let topic in this.subscriptions) {\n            if (!topic.startsWith(topicPrefix)) {\n                continue;\n            }\n\n            hasAtleastOneTopic = true;\n            for (let listener of this.subscriptions[topic]) {\n                this.eventSource?.removeEventListener(topic, listener);\n            }\n            delete this.subscriptions[topic];\n        }\n\n        if (!hasAtleastOneTopic) {\n            return; // nothing to unsubscribe from\n        }\n\n        if (this.hasSubscriptionListeners()) {\n            // submit the deleted subscriptions\n            await this.submitSubscriptions();\n        } else {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        }\n    }\n\n    /**\n     * Unsubscribe from all subscriptions matching the specified topic and listener function.\n     *\n     * This method is no-op if there are no active subscription with\n     * the specified topic and listener.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribeByTopicAndListener(topic: string, listener: EventListener): Promise<void> {\n        if (!Array.isArray(this.subscriptions[topic]) || !this.subscriptions[topic].length) {\n            return; // already unsubscribed\n        }\n\n        let exist = false;\n        for (let i = this.subscriptions[topic].length - 1; i >= 0; i--) {\n            if (this.subscriptions[topic][i] !== listener) {\n                continue;\n            }\n\n            exist = true;                           // has at least one matching listener\n            delete this.subscriptions[topic][i];    // removes the function reference\n            this.subscriptions[topic].splice(i, 1); // reindex the array\n            this.eventSource?.removeEventListener(topic, listener);\n        }\n        if (!exist) {\n            return;\n        }\n\n        // remove the topic from the subscriptions list if there are no other listeners\n        if (!this.subscriptions[topic].length) {\n            delete this.subscriptions[topic];\n        }\n\n        if (!this.hasSubscriptionListeners()) {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        } else if (!this.hasSubscriptionListeners(topic)) {\n            // submit subscriptions change if there are no other active subscriptions related to the topic\n            await this.submitSubscriptions();\n        }\n    }\n\n    private hasSubscriptionListeners(topicToCheck?: string): boolean {\n        this.subscriptions = this.subscriptions || {};\n\n        // check the specified topic\n        if (topicToCheck) {\n            return !!this.subscriptions[topicToCheck]?.length;\n        }\n\n        // check for at least one non-empty topic\n        for (let topic in this.subscriptions) {\n            if (!!this.subscriptions[topic]?.length) {\n                return true\n            }\n        }\n\n        return false;\n    }\n\n    private async submitSubscriptions(): Promise<void> {\n        if (!this.clientId) {\n            return; // no client/subscriber\n        }\n\n        // optimistic update\n        this.addAllSubscriptionListeners();\n\n        this.lastSentTopics = this.getNonEmptySubscriptionTopics();\n\n        return this.client.send('/api/realtime', {\n            'method': 'POST',\n            'body': {\n                'clientId': this.clientId,\n                'subscriptions': this.lastSentTopics,\n            },\n            'params': {\n                '$cancelKey': this.getSubscriptionsCancelKey(),\n            },\n        }).catch((err) => {\n            if (err?.isAbort) {\n                return; // silently ignore aborted pending requests\n            }\n            throw err;\n        });\n    }\n\n    private getSubscriptionsCancelKey(): string {\n        return \"realtime_\" + this.clientId;\n    }\n\n    private getNonEmptySubscriptionTopics(): Array<string> {\n        const result : Array<string> = [];\n\n        for (let topic in this.subscriptions) {\n            if (this.subscriptions[topic].length) {\n                result.push(topic);\n            }\n        }\n\n        return result;\n    }\n\n    private addAllSubscriptionListeners(): void {\n        if (!this.eventSource) {\n            return;\n        }\n\n        this.removeAllSubscriptionListeners();\n\n        for (let topic in this.subscriptions) {\n            for (let listener of this.subscriptions[topic]) {\n                this.eventSource.addEventListener(topic, listener);\n            }\n        }\n    }\n\n    private removeAllSubscriptionListeners(): void {\n        if (!this.eventSource) {\n            return;\n        }\n\n        for (let topic in this.subscriptions) {\n            for (let listener of this.subscriptions[topic]) {\n                this.eventSource.removeEventListener(topic, listener);\n            }\n        }\n    }\n\n    private async connect(): Promise<void> {\n        if (this.reconnectAttempts > 0)  {\n            // immediately resolve the promise to avoid indefinitely\n            // blocking the client during reconnection\n            return;\n        }\n\n        return new Promise((resolve, reject) => {\n            this.pendingConnects.push({ resolve, reject });\n\n            if (this.pendingConnects.length > 1) {\n                // all promises will be resolved once the connection is established\n                return;\n            }\n\n            this.initConnect();\n        })\n    }\n\n    private initConnect() {\n        this.disconnect(true);\n\n        // wait up to 15s for connect\n        clearTimeout(this.connectTimeoutId);\n        this.connectTimeoutId = setTimeout(() => {\n            this.connectErrorHandler(new Error(\"EventSource connect took too long.\"));\n        }, this.maxConnectTimeout);\n\n        this.eventSource = new EventSource(this.client.buildUrl('/api/realtime'))\n\n        this.eventSource.onerror = (_) => {\n            this.connectErrorHandler(new Error(\"Failed to establish realtime connection.\"));\n        };\n\n        this.eventSource.addEventListener('PB_CONNECT', (e) => {\n            const msgEvent = (e as MessageEvent);\n            this.clientId = msgEvent?.lastEventId;\n\n            this.submitSubscriptions()\n            .then(async () => {\n                let retries = 3;\n                while (this.hasUnsentSubscriptions() && retries > 0) {\n                    retries--;\n                    // resubscribe to ensure that the latest topics are submitted\n                    //\n                    // This is needed because missed topics could happen on reconnect\n                    // if after the pending sent `submitSubscriptions()` call another `subscribe()`\n                    // was made before the submit was able to complete.\n                    await this.submitSubscriptions();\n                }\n            }).then(() => {\n                for (let p of this.pendingConnects) {\n                    p.resolve();\n                }\n\n                // reset connect meta\n                this.pendingConnects = [];\n                this.reconnectAttempts = 0;\n                clearTimeout(this.reconnectTimeoutId);\n                clearTimeout(this.connectTimeoutId);\n            }).catch((err) => {\n                this.clientId = \"\";\n                this.connectErrorHandler(err);\n            });\n        });\n    }\n\n    private hasUnsentSubscriptions(): boolean {\n        const latestTopics = this.getNonEmptySubscriptionTopics();\n        if (latestTopics.length != this.lastSentTopics.length) {\n            return true;\n        }\n\n        for (const t of latestTopics) {\n            if (!this.lastSentTopics.includes(t)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private connectErrorHandler(err: any) {\n        clearTimeout(this.connectTimeoutId);\n        clearTimeout(this.reconnectTimeoutId);\n\n        if (\n            // wasn't previously connected -> direct reject\n            (!this.clientId && !this.reconnectAttempts) ||\n            // was previously connected but the max reconnection limit has been reached\n            this.reconnectAttempts > this.maxReconnectAttempts\n        ) {\n            for (let p of this.pendingConnects) {\n                p.reject(new ClientResponseError(err));\n            }\n            this.pendingConnects = [];\n            this.disconnect();\n            return;\n        }\n\n        // otherwise -> reconnect in the background\n        this.disconnect(true);\n        const timeout = this.predefinedReconnectIntervals[this.reconnectAttempts] || this.predefinedReconnectIntervals[this.predefinedReconnectIntervals.length - 1];\n        this.reconnectAttempts++;\n        this.reconnectTimeoutId = setTimeout(() => {\n            this.initConnect();\n        }, timeout);\n    }\n\n    private disconnect(fromReconnect = false): void {\n        clearTimeout(this.connectTimeoutId);\n        clearTimeout(this.reconnectTimeoutId);\n        this.removeAllSubscriptionListeners();\n        this.client.cancelRequest(this.getSubscriptionsCancelKey());\n        this.eventSource?.close();\n        this.eventSource = null;\n        this.clientId = \"\";\n\n        if (!fromReconnect) {\n            this.reconnectAttempts = 0;\n\n            // resolve any remaining connect promises\n            //\n            // this is done to avoid unnecessary throwing errors in case\n            // unsubscribe is called before the pending connect promises complete\n            // (see https://github.com/pocketbase/pocketbase/discussions/2897#discussioncomment-6423818)\n            for (let p of this.pendingConnects) {\n                p.resolve();\n            }\n            this.pendingConnects = [];\n        }\n    }\n}\n","import BaseService         from '@/services/utils/BaseService';\nimport { BaseQueryParams } from '@/services/utils/QueryParams';\n\nexport interface HealthCheckResponse {\n    code:    number;\n    message: string;\n    data:    {[key: string]: any};\n}\n\nexport default class HealthService extends BaseService {\n    /**\n     * Checks the health status of the api.\n     */\n    check(queryParams: BaseQueryParams = {}): Promise<HealthCheckResponse> {\n        return this.client.send('/api/health', {\n            'method': 'GET',\n            'params': queryParams,\n        });\n    }\n}\n","import BaseService from '@/services/utils/BaseService';\nimport { BaseQueryParams, FileQueryParams } from '@/services/utils/QueryParams';\n\nexport default class FileService extends BaseService {\n    /**\n     * Builds and returns an absolute record file url for the provided filename.\n     */\n    getUrl(\n        record: Pick<{[key:string]:any}, \"id\" | \"collectionId\" | \"collectionName\">,\n        filename: string,\n        queryParams: FileQueryParams = {}\n    ): string {\n        const parts = [];\n        parts.push(\"api\")\n        parts.push(\"files\")\n        parts.push(encodeURIComponent(record.collectionId || record.collectionName))\n        parts.push(encodeURIComponent(record.id))\n        parts.push(encodeURIComponent(filename))\n\n        let result = this.client.buildUrl(parts.join('/'));\n\n        if (Object.keys(queryParams).length) {\n            // normalize the download query param for consistency with the Dart sdk\n            if (queryParams.download === false) {\n                delete(queryParams.download);\n            }\n\n            const params = new URLSearchParams(queryParams);\n\n            result += (result.includes(\"?\") ? \"&\" : \"?\") + params;\n        }\n\n        return result\n    }\n\n    /**\n     * Requests a new private file access token for the current auth model (admin or record).\n     */\n    getToken(queryParams: BaseQueryParams = {}): Promise<string> {\n        return this.client.send('/api/files/token', {\n            'method': 'POST',\n            'params': queryParams,\n        }).then((data) => data?.token || '');\n    }\n}\n","import BaseService         from '@/services/utils/BaseService';\nimport { BaseQueryParams } from '@/services/utils/QueryParams';\n\nexport interface BackupFileInfo {\n    key:      string;\n    size:     number;\n    modified: string;\n}\n\nexport default class BackupService extends BaseService {\n    /**\n     * Returns list with all available backup files.\n     */\n    getFullList(queryParams: BaseQueryParams = {}): Promise<Array<BackupFileInfo>> {\n        return this.client.send('/api/backups', {\n            'method': 'GET',\n            'params': queryParams,\n        });\n    }\n\n    /**\n     * Initializes a new backup.\n     */\n    create(basename: string, queryParams: BaseQueryParams = {}): Promise<boolean> {\n        const bodyParams = {\n            'name': basename,\n        };\n\n        return this.client.send('/api/backups', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Deletes a single backup file.\n     */\n    delete(key: string, queryParams: BaseQueryParams = {}): Promise<boolean> {\n        return this.client.send(`/api/backups/${encodeURIComponent(key)}`, {\n            'method': 'DELETE',\n            'params': queryParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Initializes an app data restore from an existing backup.\n     */\n    restore(key: string, queryParams: BaseQueryParams = {}): Promise<boolean> {\n        return this.client.send(`/api/backups/${encodeURIComponent(key)}/restore`, {\n            'method': 'POST',\n            'params': queryParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Builds a download url for a single existing backup using an\n     * admin file token and the backup file key.\n     *\n     * The file token can be generated via `pb.files.getToken()`.\n     */\n    getDownloadUrl(token: string, key: string): string {\n        return this.client.buildUrl(`/api/backups/${encodeURIComponent(key)}?token=${encodeURIComponent(token)}`);\n    }\n}\n","import ClientResponseError from '@/ClientResponseError';\nimport BaseAuthStore       from '@/stores/BaseAuthStore';\nimport LocalAuthStore      from '@/stores/LocalAuthStore';\nimport SettingsService     from '@/services/SettingsService';\nimport AdminService        from '@/services/AdminService';\nimport RecordService       from '@/services/RecordService';\nimport CollectionService   from '@/services/CollectionService';\nimport LogService          from '@/services/LogService';\nimport RealtimeService     from '@/services/RealtimeService';\nimport HealthService       from '@/services/HealthService';\nimport FileService         from '@/services/FileService';\nimport BackupService       from '@/services/BackupService';\nimport { BaseQueryParams, FileQueryParams } from '@/services/utils/QueryParams';\n\nexport interface SendOptions extends RequestInit {\n    headers?: { [key: string]: string };\n    body?: any;\n    params?: BaseQueryParams;\n}\n\nexport interface BeforeSendResult {\n    [key: string]: any, // for backward compatibility\n    url?: string,\n    options?: {[key: string]: any}\n}\n\n/**\n * PocketBase JS Client.\n */\nexport default class Client {\n    /**\n     * The base PocketBase backend url address (eg. 'http://127.0.0.1.8090').\n     */\n    baseUrl: string;\n\n    /**\n     * Hook that get triggered right before sending the fetch request,\n     * allowing you to inspect and modify the url and request options.\n     *\n     * For list of the possible options check https://developer.mozilla.org/en-US/docs/Web/API/fetch#options\n     *\n     * You can return a non-empty result object `{ url, options }` to replace the url and request options entirely.\n     *\n     * Example:\n     * ```js\n     * client.beforeSend = function (url, options) {\n     *     options.headers = Object.assign({}, options.headers, {\n     *         'X-Custom-Header': 'example',\n     *     });\n     *\n     *     return { url, options }\n     * };\n     * ```\n     */\n    beforeSend?: (url: string, options: SendOptions) => BeforeSendResult|Promise<BeforeSendResult>;\n\n    /**\n     * Hook that get triggered after successfully sending the fetch request,\n     * allowing you to inspect/modify the response object and its parsed data.\n     *\n     * Returns the new Promise resolved `data` that will be returned to the client.\n     *\n     * Example:\n     * ```js\n     * client.afterSend = function (response, data) {\n     *     if (response.status != 200) {\n     *         throw new ClientResponseError({\n     *             url:      response.url,\n     *             status:   response.status,\n     *             data:     data,\n     *         });\n     *     }\n     *\n     *     return data;\n     * };\n     * ```\n     */\n    afterSend?: (response: Response, data: any) => any;\n\n    /**\n     * Optional language code (default to `en-US`) that will be sent\n     * with the requests to the server as `Accept-Language` header.\n     */\n    lang: string;\n\n    /**\n     * A replaceable instance of the local auth store service.\n     */\n    authStore: BaseAuthStore;\n\n    /**\n     * An instance of the service that handles the **Settings APIs**.\n     */\n    readonly settings: SettingsService;\n\n    /**\n     * An instance of the service that handles the **Admin APIs**.\n     */\n    readonly admins: AdminService;\n\n    /**\n     * An instance of the service that handles the **Collection APIs**.\n     */\n    readonly collections: CollectionService;\n\n    /**\n     * An instance of the service that handles the **File APIs**.\n     */\n    readonly files: FileService;\n\n    /**\n     * An instance of the service that handles the **Log APIs**.\n     */\n    readonly logs: LogService;\n\n    /**\n     * An instance of the service that handles the **Realtime APIs**.\n     */\n    readonly realtime: RealtimeService;\n\n    /**\n     * An instance of the service that handles the **Health APIs**.\n     */\n    readonly health: HealthService;\n\n    /**\n     * An instance of the service that handles the **Backup APIs**.\n     */\n    readonly backups: BackupService;\n\n    private cancelControllers: { [key: string]: AbortController } = {};\n    private recordServices: { [key: string]: RecordService } = {};\n    private enableAutoCancellation: boolean = true;\n\n    constructor(\n        baseUrl = '/',\n        authStore?: BaseAuthStore | null,\n        lang = 'en-US',\n    ) {\n        this.baseUrl   = baseUrl;\n        this.lang      = lang;\n        this.authStore = authStore || new LocalAuthStore();\n\n        // services\n        this.admins      = new AdminService(this);\n        this.collections = new CollectionService(this);\n        this.files       = new FileService(this);\n        this.logs        = new LogService(this);\n        this.settings    = new SettingsService(this);\n        this.realtime    = new RealtimeService(this);\n        this.health      = new HealthService(this);\n        this.backups     = new BackupService(this);\n    }\n\n    /**\n     * Returns the RecordService associated to the specified collection.\n     *\n     * @param  {string} idOrName\n     * @return {RecordService}\n     */\n    collection(idOrName: string): RecordService {\n        if (!this.recordServices[idOrName]) {\n            this.recordServices[idOrName] = new RecordService(this, idOrName);\n        }\n\n        return this.recordServices[idOrName];\n    }\n\n    /**\n     * Globally enable or disable auto cancellation for pending duplicated requests.\n     */\n    autoCancellation(enable: boolean): Client {\n        this.enableAutoCancellation = !!enable;\n\n        return this;\n    }\n\n    /**\n     * Cancels single request by its cancellation key.\n     */\n    cancelRequest(cancelKey: string): Client {\n        if (this.cancelControllers[cancelKey]) {\n            this.cancelControllers[cancelKey].abort();\n            delete this.cancelControllers[cancelKey];\n        }\n\n        return this;\n    }\n\n    /**\n     * Cancels all pending requests.\n     */\n    cancelAllRequests(): Client {\n        for (let k in this.cancelControllers) {\n            this.cancelControllers[k].abort();\n        }\n\n        this.cancelControllers = {};\n\n        return this;\n    }\n\n    /**\n     * Sends an api http request.\n     */\n    async send<T = any>(path: string, reqOptions: SendOptions): Promise<T> {\n        let options = Object.assign({ method: 'GET' } as SendOptions, reqOptions);\n\n        // JSON serialize the body if needed and set the correct content type\n        // (for FormData body the Content-Type header should be skipped since the boundary is autogenerated)\n        if (!this.isFormData(options.body)) {\n            if (options.body && typeof options.body !== 'string') {\n                options.body = JSON.stringify(options.body);\n            }\n\n            // add the json header (if not already)\n            if (typeof options?.headers?.['Content-Type'] === 'undefined') {\n                options.headers = Object.assign({}, options.headers, {\n                    'Content-Type': 'application/json',\n                });\n            }\n        }\n\n        // add Accept-Language header (if not already)\n        if (typeof options?.headers?.['Accept-Language'] === 'undefined') {\n            options.headers = Object.assign({}, options.headers, {\n                'Accept-Language': this.lang,\n            });\n        }\n\n        // check if Authorization header can be added\n        if (\n            // has stored token\n            this.authStore?.token &&\n            // auth header is not explicitly set\n            (typeof options?.headers?.Authorization === 'undefined')\n        ) {\n            options.headers = Object.assign({}, options.headers, {\n                'Authorization': this.authStore.token,\n            });\n        }\n\n        // handle auto cancelation for duplicated pending request\n        if (this.enableAutoCancellation && options.params?.$autoCancel !== false) {\n            const cancelKey = options.params?.$cancelKey || ((options.method || 'GET') + path);\n\n            // cancel previous pending requests\n            this.cancelRequest(cancelKey);\n\n            const controller = new AbortController();\n            this.cancelControllers[cancelKey] = controller;\n            options.signal = controller.signal;\n        }\n        // remove the special cancellation params from the other valid query params\n        delete options.params?.$autoCancel;\n        delete options.params?.$cancelKey;\n\n        // build url + path\n        let url = this.buildUrl(path);\n\n        // serialize the query parameters\n        if (typeof options.params !== 'undefined') {\n            const query = this.serializeQueryParams(options.params)\n            if (query) {\n                url += (url.includes('?') ? '&' : '?') + query;\n            }\n            delete options.params;\n        }\n\n        if (this.beforeSend) {\n            const result = Object.assign({}, await this.beforeSend(url, options));\n            if (typeof result.url !== \"undefined\" || typeof result.options !== \"undefined\") {\n                url = result.url || url;\n                options = result.options || options;\n            } else if (Object.keys(result).length) {\n                // legacy behavior\n                options = result as SendOptions;\n                console?.warn && console.warn(\"Deprecated format of beforeSend return: please use `return { url, options }`, instead of `return options`.\");\n            }\n        }\n\n        // send the request\n        return fetch(url, options)\n            .then(async (response) => {\n                let data : any = {};\n\n                try {\n                    data = await response.json();\n                } catch (_) {\n                    // all api responses are expected to return json\n                    // with the exception of the realtime event and 204\n                }\n\n                if (this.afterSend) {\n                    data = await this.afterSend(response, data);\n                }\n\n                if (response.status >= 400) {\n                    throw new ClientResponseError({\n                        url:      response.url,\n                        status:   response.status,\n                        data:     data,\n                    });\n                }\n\n                return data as T;\n            }).catch((err) => {\n                // wrap to normalize all errors\n                throw new ClientResponseError(err);\n            });\n    }\n\n    /**\n     * Legacy alias of `pb.files.getUrl()`.\n     */\n    getFileUrl(\n        record: Pick<{[key:string]:any}, \"id\" | \"collectionId\" | \"collectionName\">,\n        filename: string,\n        queryParams: FileQueryParams = {}\n    ): string {\n        return this.files.getUrl(record, filename, queryParams);\n    }\n\n    /**\n     * Builds a full client url by safely concatenating the provided path.\n     */\n    buildUrl(path: string): string {\n        let url = this.baseUrl;\n\n        // construct an absolute base url if in a browser environment\n        if (\n            typeof window !== 'undefined' &&\n            !!window.location &&\n            !url.startsWith('https://') &&\n            !url.startsWith('http://')\n        ) {\n            url = window.location.origin?.endsWith('/') ?\n                window.location.origin.substring(0, window.location.origin.length - 1) :\n                (window.location.origin || '');\n\n            if (!this.baseUrl.startsWith('/')) {\n                url += window.location.pathname || '/';\n                url += url.endsWith('/') ? '' : '/';\n            }\n\n            url += this.baseUrl;\n        }\n\n        // concatenate the path\n        if (path) {\n            url += url.endsWith('/') ? '' : '/'; // append trailing slash if missing\n            url += path.startsWith('/') ? path.substring(1) : path;\n        }\n\n        return url;\n    }\n\n    /**\n     * Loosely checks if the specified body is a FormData instance.\n     */\n    private isFormData(body: any): boolean {\n        return body && (\n            // we are checking the constructor name because FormData\n            // is not available natively in some environments and the\n            // polyfill(s) may not be globally accessible\n            body.constructor.name === 'FormData' ||\n            // fallback to global FormData instance check\n            // note: this is needed because the constructor.name could be different in case of\n            //       custom global FormData implementation, eg. React Native on Android/iOS\n            (typeof FormData !== \"undefined\" && body instanceof FormData)\n        )\n    }\n\n    /**\n     * Serializes the provided query parameters into a query string.\n     */\n    private serializeQueryParams(params: {[key: string]: any}): string {\n        const result: Array<string> = [];\n        for (const key in params) {\n            if (params[key] === null) {\n                // skip null query params\n                continue;\n            }\n\n            const value = params[key];\n            const encodedKey = encodeURIComponent(key);\n\n            if (Array.isArray(value)) {\n                // \"repeat\" array params\n                for (const v of value) {\n                    result.push(encodedKey + \"=\" + encodeURIComponent(v));\n                }\n            } else if (value instanceof Date) {\n                result.push(encodedKey + \"=\" + encodeURIComponent(value.toISOString()));\n            } else if (typeof value !== null && typeof value === 'object') {\n                result.push(encodedKey + \"=\" + encodeURIComponent(JSON.stringify(value)));\n            } else {\n                result.push(encodedKey + \"=\" + encodeURIComponent(value));\n            }\n        }\n\n        return result.join('&');\n    }\n}\n"],"names":["ClientResponseError","Error","constructor","errData","super","this","url","status","response","isAbort","originalError","Object","setPrototypeOf","prototype","data","DOMException","name","message","_a","_d","_c","_b","cause","includes","toJSON","assign","fieldContentRegExp","cookieSerialize","val","options","opt","encode","defaultEncode","test","TypeError","value","result","maxAge","isNaN","isFinite","Math","floor","domain","path","expires","isDate","toString","call","Date","valueOf","toUTCString","httpOnly","secure","priority","toLowerCase","sameSite","defaultDecode","indexOf","decodeURIComponent","encodeURIComponent","atobPolyfill","getTokenPayload","token","encodedPayload","split","map","c","charCodeAt","slice","join","JSON","parse","e","atob","input","str","String","replace","length","bs","buffer","bc","idx","output","charAt","fromCharCode","defaultCookieKey","BaseAuthStore","baseToken","baseModel","_onChangeCallbacks","model","isValid","isTokenExpired","expirationThreshold","payload","keys","exp","now","save","triggerChange","clear","loadFromCookie","cookie","key","rawData","cookieParse","decode","index","eqIdx","endIdx","lastIndexOf","trim","undefined","_","Array","isArray","exportToCookie","defaultOptions","stringify","resultLength","Blob","size","id","email","extraProps","prop","onChange","callback","fireImmediately","push","i","splice","LocalAuthStore","storageKey","storageFallback","_storageGet","_storageSet","_storageRemove","window","localStorage","rawValue","getItem","normalizedVal","setItem","removeItem","BaseService","client","SettingsService","getAll","queryParams","send","method","params","then","responseData","update","bodyParams","body","testS3","filesystem","testEmail","toEmail","emailTemplate","template","generateAppleClientSecret","clientId","teamId","keyId","privateKey","duration","CrudService","getFullList","batchOrqueryParams","_getFullList","batch","getList","page","perPage","baseCrudPath","items","item","getFirstListItem","filter","skipTotal","$cancelKey","code","getOne","create","batchSize","request","__awaiter","list","concat","AdminService","BaseCrudService","authStore","collectionId","delete","success","authResponse","admin","authWithPassword","password","identity","bind","authRefresh","requestPasswordReset","confirmPasswordReset","passwordResetToken","passwordConfirm","RecordService","collectionIdOrName","baseCollectionPath","subscribeOne","recordId","console","warn","realtime","subscribe","topicOrCallback","topic","unsubscribe","unsubscribeByPrefix","batchOrQueryParams","collectionName","record","listAuthMethods","usernamePassword","emailPassword","authProviders","usernameOrEmail","authWithOAuth2Code","provider","codeVerifier","redirectUrl","createData","authWithOAuth2","args","config","find","p","buildUrl","Promise","resolve","reject","oldState","state","authData","query","err","replacements","scopes","_replaceQueryParams","authUrl","urlCallback","_defaultUrlCallback","requestVerification","confirmVerification","verificationToken","requestEmailChange","newEmail","confirmEmailChange","emailChangeToken","listExternalAuths","unlinkExternalAuth","urlPath","substring","parsedParams","rawParams","param","pair","hasOwnProperty","open","width","height","windowWidth","innerWidth","windowHeight","innerHeight","left","top","CollectionService","import","collections","deleteMissing","LogService","getRequestsList","getRequest","getRequestsStats","RealtimeService","eventSource","subscriptions","lastSentTopics","maxConnectTimeout","reconnectAttempts","maxReconnectAttempts","Infinity","predefinedReconnectIntervals","pendingConnects","isConnected","listener","msgEvent","submitSubscriptions","addEventListener","connect","unsubscribeByTopicAndListener","hasSubscriptionListeners","removeEventListener","disconnect","topicPrefix","hasAtleastOneTopic","startsWith","exist","topicToCheck","addAllSubscriptionListeners","getNonEmptySubscriptionTopics","getSubscriptionsCancelKey","catch","removeAllSubscriptionListeners","initConnect","clearTimeout","connectTimeoutId","setTimeout","connectErrorHandler","EventSource","onerror","lastEventId","retries","hasUnsentSubscriptions","reconnectTimeoutId","latestTopics","t","timeout","fromReconnect","cancelRequest","close","HealthService","check","FileService","getUrl","filename","parts","download","URLSearchParams","getToken","BackupService","basename","restore","getDownloadUrl","Client","baseUrl","lang","cancelControllers","recordServices","enableAutoCancellation","admins","files","logs","settings","health","backups","collection","idOrName","autoCancellation","enable","cancelKey","abort","cancelAllRequests","k","reqOptions","isFormData","headers","Authorization","_e","$autoCancel","_f","controller","AbortController","signal","_g","_h","serializeQueryParams","beforeSend","fetch","json","afterSend","getFileUrl","location","origin","endsWith","pathname","FormData","encodedKey","v","toISOString"],"mappings":"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"}